{"ast":null,"code":"/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\n\nexport function findLabelTextShape(label) {\n  return label.find(function (el) {\n    return el.get('type') === 'text';\n  });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\n\nexport function getLabelBackgroundInfo(labelGroup, labelItem, padding) {\n  if (padding === void 0) {\n    padding = [0, 0, 0, 0];\n  }\n\n  var content = labelGroup && labelGroup.getChildren()[0];\n\n  if (content) {\n    var labelShape = content.clone(); // revert rotate\n\n    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n      rotate(labelShape, -labelItem.rotate);\n    } // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n\n\n    var _a = labelShape.getCanvasBBox(),\n        x = _a.x,\n        y = _a.y,\n        width = _a.width,\n        height = _a.height;\n\n    labelShape.destroy();\n    var boxPadding = padding;\n\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    rotation: 0\n  };\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\n\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\n\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"mappings":"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","names":["isNil","isNumber","some","rotate","findLabelTextShape","label","find","el","get","getLabelBackgroundInfo","labelGroup","labelItem","padding","content","getChildren","labelShape","clone","getCanvasBBox","x","y","width","height","destroy","boxPadding","Array","fill","rotation","getOverlapArea","a","b","margin","xOverlap","Math","max","min","yOverlap","checkShapeOverlap","cur","dones","box","getBBox","done","target"],"sources":["E:\\office_react\\Context_Practice\\Context-Frontent_practice\\node_modules\\@antv\\g2\\src\\geometry\\label\\util\\index.ts"],"sourcesContent":["/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: { rotate?: number;[key: string]: any },\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n\n  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}