{"ast":null,"code":"import { DIRECTION } from '../constant';\n/**\n * @ignore\n * 方位常量转实际的 bbox 位置大小\n * @param parentBBox\n * @param bbox\n * @param direction\n */\n\nexport function directionToPosition(parentBBox, bbox, direction) {\n  if (direction === DIRECTION.TOP) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];\n  }\n\n  if (direction === DIRECTION.BOTTOM) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];\n  }\n\n  if (direction === DIRECTION.LEFT) {\n    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n\n  if (direction === DIRECTION.RIGHT) {\n    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n\n  if (direction === DIRECTION.TOP_LEFT || direction === DIRECTION.LEFT_TOP) {\n    return [parentBBox.tl.x, parentBBox.tl.y];\n  }\n\n  if (direction === DIRECTION.TOP_RIGHT || direction === DIRECTION.RIGHT_TOP) {\n    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];\n  }\n\n  if (direction === DIRECTION.BOTTOM_LEFT || direction === DIRECTION.LEFT_BOTTOM) {\n    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];\n  }\n\n  if (direction === DIRECTION.BOTTOM_RIGHT || direction === DIRECTION.RIGHT_BOTTOM) {\n    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];\n  }\n\n  return [0, 0];\n}\n/**\n * get direction after coordinate transpose\n * @param direction\n * @param coordinate\n * @returns direction after transpose or not\n */\n\nfunction getTransposedDirection(direction, coordinate) {\n  if (coordinate.isTransposed) {\n    switch (direction) {\n      case DIRECTION.BOTTOM:\n        return DIRECTION.LEFT;\n\n      case DIRECTION.LEFT:\n        return DIRECTION.BOTTOM;\n\n      case DIRECTION.RIGHT:\n        return DIRECTION.TOP;\n\n      case DIRECTION.TOP:\n        return DIRECTION.RIGHT;\n    }\n  }\n\n  return direction;\n}\n\nfunction reflectX(direct) {\n  if (direct === DIRECTION.LEFT) {\n    return DIRECTION.RIGHT;\n  }\n\n  if (direct === DIRECTION.RIGHT) {\n    return DIRECTION.LEFT;\n  }\n\n  return direct;\n}\n\nfunction reflectY(direct) {\n  if (direct === DIRECTION.TOP) {\n    return DIRECTION.BOTTOM;\n  }\n\n  if (direct === DIRECTION.BOTTOM) {\n    return DIRECTION.TOP;\n  }\n\n  return direct;\n}\n/**\n * get direction after coordinate.scale\n * @param direction\n * @param coordinate\n */\n\n\nfunction getScaleDirection(direction, coordinate) {\n  var x = coordinate.matrix[0];\n  var y = coordinate.matrix[4];\n  var d = direction;\n\n  if (x < 0) {\n    d = reflectX(d);\n  }\n\n  if (y < 0) {\n    d = reflectY(d);\n  }\n\n  return d;\n}\n/**\n *\n * @param direction\n * @param coordinate\n */\n\n\nfunction getReflectDirection(direction, coordinate) {\n  var d = direction;\n\n  if (coordinate.isReflect('x')) {\n    d = reflectX(d);\n  }\n\n  if (coordinate.isReflect('y')) {\n    d = reflectY(d);\n  }\n\n  return d;\n}\n/**\n * @ignore\n * get direction after coordinate translate\n * @param direction\n * @param coordinate\n */\n\n\nexport function getTranslateDirection(direction, coordinate) {\n  var d = direction;\n  d = getTransposedDirection(d, coordinate);\n  d = getScaleDirection(d, coordinate);\n  d = getReflectDirection(d, coordinate);\n  return d;\n}","map":{"version":3,"mappings":"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","names":["DIRECTION","directionToPosition","parentBBox","bbox","direction","TOP","minX","width","minY","BOTTOM","maxY","height","LEFT","RIGHT","maxX","TOP_LEFT","LEFT_TOP","tl","x","y","TOP_RIGHT","RIGHT_TOP","tr","BOTTOM_LEFT","LEFT_BOTTOM","bl","BOTTOM_RIGHT","RIGHT_BOTTOM","br","getTransposedDirection","coordinate","isTransposed","reflectX","direct","reflectY","getScaleDirection","matrix","d","getReflectDirection","isReflect","getTranslateDirection"],"sources":["E:\\office_react\\Context_Practice\\Context-Frontent_practice\\node_modules\\@antv\\g2\\src\\util\\direction.ts"],"sourcesContent":["import { DIRECTION } from '../constant';\nimport { Coordinate } from '../dependents';\nimport { Position } from '../interface';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * 方位常量转实际的 bbox 位置大小\n * @param parentBBox\n * @param bbox\n * @param direction\n */\nexport function directionToPosition(parentBBox: BBox, bbox: BBox, direction: DIRECTION): Position {\n  if (direction === DIRECTION.TOP) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];\n  }\n  if (direction === DIRECTION.BOTTOM) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];\n  }\n  if (direction === DIRECTION.LEFT) {\n    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n  if (direction === DIRECTION.RIGHT) {\n    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n\n  if (direction === DIRECTION.TOP_LEFT || direction === DIRECTION.LEFT_TOP) {\n    return [parentBBox.tl.x, parentBBox.tl.y];\n  }\n  if (direction === DIRECTION.TOP_RIGHT || direction === DIRECTION.RIGHT_TOP) {\n    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];\n  }\n  if (direction === DIRECTION.BOTTOM_LEFT || direction === DIRECTION.LEFT_BOTTOM) {\n    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];\n  }\n  if (direction === DIRECTION.BOTTOM_RIGHT || direction === DIRECTION.RIGHT_BOTTOM) {\n    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];\n  }\n\n  return [0, 0];\n}\n\n/**\n * get direction after coordinate transpose\n * @param direction\n * @param coordinate\n * @returns direction after transpose or not\n */\nfunction getTransposedDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  if (coordinate.isTransposed) {\n    switch (direction) {\n      case DIRECTION.BOTTOM:\n        return DIRECTION.LEFT;\n      case DIRECTION.LEFT:\n        return DIRECTION.BOTTOM;\n      case DIRECTION.RIGHT:\n        return DIRECTION.TOP;\n      case DIRECTION.TOP:\n        return DIRECTION.RIGHT;\n    }\n  }\n  return direction;\n}\n\nfunction reflectX(direct: DIRECTION): DIRECTION {\n  if (direct === DIRECTION.LEFT) {\n    return DIRECTION.RIGHT;\n  }\n\n  if (direct === DIRECTION.RIGHT) {\n    return DIRECTION.LEFT;\n  }\n\n  return direct;\n}\n\nfunction reflectY(direct: DIRECTION): DIRECTION {\n  if (direct === DIRECTION.TOP) {\n    return DIRECTION.BOTTOM;\n  }\n  if (direct === DIRECTION.BOTTOM) {\n    return DIRECTION.TOP;\n  }\n\n  return direct;\n}\n\n/**\n * get direction after coordinate.scale\n * @param direction\n * @param coordinate\n */\nfunction getScaleDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  const x = coordinate.matrix[0];\n  const y = coordinate.matrix[4];\n\n  let d = direction;\n  if (x < 0) {\n    d = reflectX(d);\n  }\n  if (y < 0) {\n    d = reflectY(d);\n  }\n  return d;\n}\n\n/**\n *\n * @param direction\n * @param coordinate\n */\nfunction getReflectDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  let d = direction;\n\n  if (coordinate.isReflect('x')) {\n    d = reflectX(d);\n  }\n  if (coordinate.isReflect('y')) {\n    d = reflectY(d);\n  }\n\n  return d;\n}\n\n/**\n * @ignore\n * get direction after coordinate translate\n * @param direction\n * @param coordinate\n */\nexport function getTranslateDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  let d = direction;\n  d = getTransposedDirection(d, coordinate);\n  d = getScaleDirection(d, coordinate);\n  d = getReflectDirection(d, coordinate);\n\n  return d;\n}\n"]},"metadata":{},"sourceType":"module"}